use std::{
    io::Write,
    path::{Path, PathBuf},
};

use anyhow::{bail, Context};
use cynic::QueryBuilder;

use linear_api::schema::issue_get::{IssueGet, IssueGetVariables};

use crate::cmd::{CliCommand, CommonArgs, Format};

/// Checkout or create the GIT branch for an issue.
///
/// Will use the branch name generated by Linear.
/// Requires the current directory to be inside a Git repository.
// TODO: check if a PR is already open for the issue, and use the existing branch.
#[derive(clap::Parser)]
pub struct CmdIssueCheckout {
    #[clap(flatten)]
    common: CommonArgs,

    #[clap(long, short, default_value = "table")]
    pub format: Format,

    /// Path to the Git repository.
    ///
    /// Defaults to the current working directory.
    #[clap(long)]
    pub repo: Option<PathBuf>,

    pub issue_id: String,
}

impl CliCommand for CmdIssueCheckout {
    type Output = ();

    async fn run(self) -> Result<(), anyhow::Error> {
        // Make sure the provided --repo or current dir is a Git repo.
        let repo_path = if let Some(p) = self.repo {
            p
        } else {
            std::env::current_dir()?
        };
        if !path_is_git_repo(repo_path.clone())? {
            bail!("No Git repo found at '{}'", repo_path.display());
        }

        // Load the issue to determine the branch name.
        let vars = IssueGetVariables {
            id: self.issue_id.clone(),
        };
        let op = IssueGet::build(vars);

        let issue = self
            .common
            .client()?
            .run(op)
            .await?
            .data
            .with_context(|| format!("issue {} not found", self.issue_id))?
            .issue;

        let branch = issue.branch_name;
        eprintln!(
            "Checking out Git branch '{}' for issue {}",
            branch, self.issue_id
        );

        let branches = git_list_branches(&repo_path)?;
        let branch_exists = branches.contains(&branch);

        if branch_exists {
            let status = std::process::Command::new("git")
                .args(["switch", &branch])
                .spawn()?
                .wait()?;
            if !status.success() {
                bail!("Could not execute 'git switch ...'");
            }
            eprintln!("Switched to existing Git branch: {}", branch);
        } else {
            let status = std::process::Command::new("git")
                .args(["switch", "-c", &branch])
                .spawn()?
                .wait()?;
            if !status.success() {
                bail!("Could not execute 'git switch ...'");
            }
            eprintln!("Created and checked out new Git branch: {}", branch);
        }

        Ok(())
    }
}

fn path_is_git_repo(mut path: PathBuf) -> Result<bool, anyhow::Error> {
    let exists = loop {
        let git_dir = path.join(".git");
        if git_dir.try_exists()? {
            break true;
        }
        if let Some(parent) = path.parent() {
            path = parent.to_owned();
        } else {
            break false;
        }
    };

    Ok(exists)
}

fn git_list_branches(path: &Path) -> Result<Vec<String>, anyhow::Error> {
    let out = std::process::Command::new("git")
        .current_dir(path)
        .args(["for-each-ref", "--format='%(refname:short)'", "refs/heads"])
        .output()
        .context("failed to execute 'git for-each-ref'")?;
    if !out.status.success() {
        let mut stderr = std::io::stderr().lock();
        stderr.write_all(&out.stderr)?;
        bail!("Executing 'git for-each-ref' failed");
    }

    let stdout = String::from_utf8(out.stdout).context("non-utf8 output")?;
    let branches = stdout
        .trim()
        .lines()
        .map(|x| x.trim_matches('\'').to_string())
        .collect::<Vec<_>>();

    Ok(branches)
}
